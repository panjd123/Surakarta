## 第一阶段
#### 规则实现算法
**基本游戏实现与规则判断：** 
  首先对于棋子的储存，我们声明了棋子类，用来存储棋子的颜色，id，坐标，是否死亡。这样存储的好处是便于能够在后续画棋子/走棋子等函数中实现。
  其次需要注意的是：
  1.关于鼠标坐标与棋盘坐标的转换。
    我们用了坐标转换函数实现。
  2.关于turn的转换与判断。
    我们用了bool类型的flag来进行记录与判断，这样能够实现在某一个棋子turn时候不会错点其他棋子，同时能够内部自己换要走的棋子。
  3.关于规则。
    判断不出界/没有自食/没有移动空白棋子/判断非吃子移动是否合法等常规易于判断的规则与阶段一一致，在此处不再赘述。
  4.棋盘绘画。

**游戏可视化界面与进一步游戏功能实现：** 
  MainWindow主界面，用来控制Board类。MainWindow内有选择模式（人机，ai,网络等），其中该类包含了悔棋、投降、超时检测等操作，由Board信号驱动，启动游戏开始定时器，当定时器开始时，会通过Board类判断当前由哪位用户在操作，并判断超时时间
  class Board{
public:
    QVector<Stone> _s;      			//当前进行棋子
    QVector<Stone> _s_back;		//悔棋
    QVector<Stone> _s_reset;		//重新开始
void Board::mouseReleaseEvent(QMouseEvent *ev)//选择棋子
{
    copyStone(_s_back,_s);   //这里鼠标松下的时候，会把之前的棋子布局和状态记录下来
class Board{
void undo();   //悔棋  
    bool getUser1(){return bTurn;}  //获取当前用户
    void reset(); //重新开始

  遇到的问题：
  1.发现左上角棋子的颜色有问题，查明原因为之前的代码绘制了32个棋子，而本游戏只需要24个，改正后可以正常运行。
  2.12号棋子无法移动，查明原因为判断条件不完善，改正后问题解决。

  
**游戏界面美化：** 
  通过样式表和QSS等实现简单的美化，在此不再赘述。
  

#### 分工
**代码量**  目前该阶段代码在游戏实现阶段（包括棋盘建立/整个游戏的完整流程成功运行至一方输）由秦禛涵2023202271完成，按钮与其对应功能（包括悔棋/倒计时/认输等功能）由苏楷棋2023202240完成，游戏美化阶段（包括按钮形态设计/样式表调整/背景图片制作）由秦禛涵2023202271完成。

**测试**    秦禛涵2023202271，苏楷棋2023202240参与了代码测试与debug。


 
