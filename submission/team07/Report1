#第一阶段报告

## 游戏规则算法
### *JudgeEnd*算法：

1. 判断是否有非法走子。若有，返回```ILLIGAL_MOVE```，游戏结束。
2. 遍历整个棋盘，计算黑白棋子数。若有一方棋子数为0，返回```CHECKMATE```，游戏结束。
3. 若当前回合没有发生吃子，且双方超过```max_no_capture_round_```个回合没有吃子，返回```STALEMATE```，游戏结束。
4. 若以上条件都不满足，返回```NONE```，游戏继续。

---

### *JudgeMove*算法：

1. 检查是否轮到当前玩家移动。如果不是，返回```NOT_PLAYER_TURN```.

2. 检查移动的起始位置和目标位置是否在棋盘内。如果超出棋盘范围，返回```OUT_OF_BOARD```.

3. 检查移动的起始位置是否有棋子，如果没有，返回```NOT_PIECE```；检查移动起始位置是否为当前玩家的棋子，如果不是，返回```NOT_PLAYER_PIECE```.

4. 判断移动目标位置棋子情况即颜色：

   - 如果目标位置为当前玩家的棋子，返回```ILLIGAL_NON_CAPTURE_MOVE```.

   - 如果目标位置没有棋子，则检查当前移动是否为邻移，如果不是，则返回```ILLIGAL_NON_CAPTURE_MOVE```；否则，返回```LEGAL_NON_CAPTURE_MOVE```.

   - 如果目标位置为对方棋子，则根据**助教的算法**判断当前吃子是否合法。如果非法，返回```ILLIGAL_CAPTURE_MOVE```；否则返回```LEGAL_CAPTURE_MOVE```.

     > 吃子判断具体实现：
     >
     > - 以左上角第一个棋子为起始点，以逆时针方向移动，提取出两个环上的所有棋子。
     > - 根据提取的棋子分布情况，记录下逆时针方向所有相邻的直线。
     > - 将移动的起始位置和目标位置的横纵坐标通过```row_line```函数映射到四条直线的下标0、1、2、3，不在四条直线上都映射为4.
     > - 然后判断初始位置和目标位置是否在相邻的直线上。逆时针吃子情况：起始位置是直线上最后一个棋子，目标位置是直线上第一个棋子。顺时针吃子情况，将起始位置和目标位置交换，进行相同的判断。如果是，返回```LEGAL_CAPTURE_MOVE```。

*注*：要在JudgeMove最后随便加上一个返回值。

> 请检查一下你们的 `SurakartaIllegalMoveReason SurakartaRuleManager::JudgeMove` 函数，这个函数并不总有返回值
> 这导致编译器自动优化掉了最后一个条件语句，你们可以在函数最后随便返回一个什么 `SurakartaIllegalMoveReason` 来避免这种错误的优化
> 这体现了编译过程无警告的重要性，因为返回值非空的函数如果不总返回一个值，编译器实际上会给出警告
##AI算法
贪心：
1.遍历棋盘，找到我方棋子
2确定下我方棋子（i，j），对其进行CalculateMove，即遍历棋盘，按照一定的规则，对它可能的落点打分
3.遍历完所有落点，取得分最高的落点（m，n）作为（i,j）的分数
4遍历我方棋子，取分数最高的起始点作为from，from对应的最高分落点作为to
5.更新棋盘
*注*：2中的函数可以根据需求有不同实现。这里采取的是“能吃子加大分，不被吃加小分，被吃减小分，不合法移动减大分”
