# 第一阶段报告 

## 游戏规则算法 

### *JudgeEnd*算法： 

   1. 判断是否有非法走子。若有，返回```ILLIGAL_MOVE```，游戏结束。 

  2. 遍历整个棋盘，计算黑白棋子数。若有一方棋子数为0，返回```CHECKMATE```，游戏结束。 

  3. 若当前回合没有发生吃子，且双方超过```max_no_capture_round_```个回合没有吃子，返回```STALEMATE```，游戏结束。 

  4. 若以上条件都不满足，返回```NONE```，游戏继续。 

     ---

### *JudgeMove*算法： 

   1. 检查是否轮到当前玩家移动。如果不是，返回```NOT_PLAYER_TURN```. 
  
   2. 检查移动的起始位置和目标位置是否在棋盘内。如果超出棋盘范围，返回```OUT_OF_BOARD```. 
  
   3. 检查移动的起始位置是否有棋子，如果没有，返回```NOT_PIECE```；检查移动起始位置是否为当前玩家的棋子，如果不是，返回```NOT_PLAYER_PIECE```. 
  
   4. 判断移动目标位置棋子情况即颜色： 

   - 如果目标位置为当前玩家的棋子，返回```ILLIGAL_NON_CAPTURE_MOVE```. 
  
   - 如果目标位置没有棋子，则检查当前移动是否为邻移，如果不是，则返回```ILLIGAL_NON_CAPTURE_MOVE```；否则，返回```LEGAL_NON_CAPTURE_MOVE```. 
  
   - 如果目标位置为对方棋子，则根据**助教的算法**判断当前吃子是否合法。如果非法，返回```ILLIGAL_CAPTURE_MOVE```；否则返回```LEGAL_CAPTURE_MOVE```. 

   > 吃子判断具体实现： 
   >
   > - 以左上角第一个棋子为起始点，以逆时针方向移动，提取出两个环上的所有棋子。 
   > - 根据提取的棋子分布情况，记录下逆时针方向所有相邻的直线。 
   > - 将移动的起始位置和目标位置的横纵坐标通过```row_line```函数映射到四条直线的下标0、1、2、3，不在四条直线上都映射为4. 
   > - 然后判断初始位置和目标位置是否在相邻的直线上。逆时针吃子情况：起始位置是直线上最后一个棋子，目标位置是直线上第一个棋子。顺时针吃子情况，将起始位置和目标位置交换，进行相同的判断。如果是，返回```LEGAL_CAPTURE_MOVE```。 

   *注*：要在JudgeMove最后随便加上一个返回值。 

   > 请检查一下你们的 `SurakartaIllegalMoveReason SurakartaRuleManager::JudgeMove` 函数，这个函数并不总有返回值 
   > 这导致编译器自动优化掉了最后一个条件语句，你们可以在函数最后随便返回一个什么 `SurakartaIllegalMoveReason` 来避免这种错误的优化 
   > 这体现了编译过程无警告的重要性，因为返回值非空的函数如果不总返回一个值，编译器实际上会给出警告 

---

### AI算法 

*贪心*： 

1. 遍历棋盘，找到我方棋子 

2. 确定下我方棋子（i，j），对其进行```CalculateMove```，即遍历棋盘，按照一定的规则，对它可能的落点打分 

3. 遍历完所有落点，取得分最高的落点（m，n）作为（i,j）的分数 

4. 遍历我方棋子，取分数最高的起始点作为from，from对应的最高分落点作为to 

5. 更新棋盘 

   *注*：2中的函数可以根据需求有不同实现。这里采取的是“能吃子加大分，不被吃加小分，被吃减小分，不合法移动减大分” 