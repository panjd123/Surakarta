## 第一阶段

我们小组算法的优势：
规则实现：

AI:
我们编写了一个比较强大的加分机制，根据大量测试胜率能够在80%以上，其中一个亮点在于对局势的处理
遍历棋盘，统计棋子个数，讨论：
当棋子个数>=一半时,这个时候因为大量的子相互关联，相互生根，可根据不同的位置加上一个匹配该位置的分数
当棋子个数<一半时，这个时候主要考虑避免被吃以及避免落入死角或者绝境；

#### 规则实现算法：
Judge_End:

1. 遍历棋盘，记录双方数量，如果有一方只有一个棋子而对方还有棋子，并且当前轮到的玩家可以合法吃子，则判定CHECKMATE，返回对应的结果。
3. 若Judge_Move判断为ILLIGAL_CAPTURE_MOVE，判断当前轮到的玩家为黑色还是白色，返回对应的非法移动结束结果。
4. 如果达到最大无吃子回合数，且当前轮到的玩家没有吃子，则根据棋子数量判断平局结果，返回对应的结果。

最后，如果以上条件都不符合，则返回游戏未结束的结果。

Judge_Move:

**基本规则判断：**

1.先判断是否是当前选手所在回合。
2.判断是否出界。
3.判断from是不是己方棋子，空白棋和对方棋结束。
4.判断to是什么类型棋子，己方棋子结束，对方棋子旋吃判断，空白棋邻移判断。

**邻移判断：**

1.判断to与from的x,y各自差值绝对值是否小于等于1。

**旋吃判断：** 

应该注意到，旋吃一开始只能向4个方向走，且一旦方向选定，后面的旋转时的坐标转换，走的路径全部确定。要么路上有其他棋子，要么到to所在位置，要么回到from所在位置。

1.在坐标未发生转换之前，碰到棋子就应该返回。

2.坐标发生转换之后，有三种情况返回：

1.到to；

2.到from；

3.路上有棋子。

所以只要写4个函数表示向4个方向遍历棋盘，只要有一个方向能到to就行。



#### AI算法

**算法** 

编写一个加分机制:

1.若这一步能吃子，直接return。

2.若这一步不能吃子：

1.粗略讨论位置，处于中心位置的棋子以及关键交叉位置会加上一个较高的分值，处于角落或者边界上的棋子加上一个较低分值。

2.更新并遍历棋盘，讨论下一步移子，若reason == SurakartaIllegalMoveReason::LEGAL_CAPTURE_MOVE（实际上是被吃）,分为两种情况，若目前玩家棋子数目>=6个，则加分（棋子数目多时基本上是换子）；否则，减分（不能白送）；

根据最高分数return best_score。              


#### 分工

**代码** 
该阶段规则判断代码为廖祥宇2023202313完成，AI算法为刘远航2023202275完成。

**调错完善** 
代码调错完善由徐巍威2023202286负责，保证了代码的可运行性，完整性，整洁性。

