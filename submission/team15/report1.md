# 第一阶段报告

## 一、规则实现

### 1.judgemove

* 移动是否超出棋盘边界：将move.from坐标、move.to坐标与boardsize作比较。

* 判断是否操作非棋子的位置：判断move.from棋子颜色是否不是黑色也不是白色。

* 判断是否是合法玩家在操作：将当前玩家与实际玩家比较。

* 判断玩家是否正确移动己方棋子：将move.from的棋子颜色与玩家颜色相比较。

* 判断是否是合法的不吃子移动：移动范围在上下左右、左上、左下、右上、右下八个位置范围内且目标位置不能有棋子。

* 旋吃：我们首先确定起始位置是在哪个环上，为了避免不同环交叉位置的影响，在分类讨论时，我们选取了互不干扰的行或列。旋吃在一个环道上无非只有两条路，即顺时针和逆时针，为了提高代码的可重复性，我们为棋子的信息设置了坐标与移动方向（方向即direction，1代表向左，2代表向右，3代表向上，4代表向下）。在while循环中，只要没碰到目标棋子，循环就会模拟棋子移动遍历，在遇到旋的时候更改棋子位置与移动方向，并且将经过旋的次数times+1。如果遇到了非目标棋子同时非初始位置，就算遇到了障碍，此时flag+1。最后判断是否合法时，就要看times是否大于零，并且flag是否等于0，两项都满足才算合法。

* n!=6的情况：我们用for循环遍历环道的行或列即可实现。

  

### 2.judgeend

* 如果走出非法步，自动结束。

* 只剩一个棋子时，该棋子可以被对手吃，那么游戏结束。

* 未吃子轮数超过设置的最大轮数，再看哪方棋子多。

  

## 二、AI实现

我们一开始用的贪心算法，但发现我们的打分规则并不合理，单单推演两步棋并不能凸显其副作用，所以我们改用了简单的minmax搜索算法。

（还未实现，以下只有思路）

前提：判断移动方式是合规的；使用递归比较不同移动棋子的方式的合理性

具体思路：

1. 棋盘上不同位置的重要性不同，对应不同的分数。
2. 重要性越高，对应位置的分数越高。比如棋盘四个角的位置的分数最低，在大环线路或者小环线路上的位置的分数更高，且由于在该位置的棋子的防御能力和吃子能力的不同，分数会有参差。若有我方棋子在这个位置上，则获得这个位置对应的分数，通过比较当前棋盘的总分（即：将所有我方棋子所在位置的对应的分数相加），来判断形势是否对我方有利，棋盘对应的分数越高，越有利。
3. 递归过程：

1）遍历所有我方棋子的合法移动方式，记录下第一层递归中我方棋子的移动方式，用于最后返回函数值

2）我方走完一步后，遍历对方所有的合法移动方式，进入下一层递归

3）在第四层递归（即最后一层递归）中，记录对方移动棋子后，当下棋盘的总分

4.通过四层递归，记录不同走法下，未来四次双方移动棋子后对应的棋盘分数来判断走这一步是否合理，分数最高的走法即是判断为最合理的走法，最终返回该移动方式

## 三、遇到的问题及解决方法

### 1.规则实现

思路其实并没有问题，只是代码中会有些小的手误写错了。并且在测试时并没有及时去更新助教的改动，没有先删除build再测试导致在这方面消耗很多时间。

### 2.AI实现

打分的规则不完善（minmax搜索最底层给棋盘打分）：参考了一些论文文献，在报告最后标注。

## 四、分工

* 规则实现：王粲然
* AI实现：待定
* 实验报告：王粲然、杨昱文

> 刘璇，陶秋子，赵洪飞，等.计算机博弈苏拉卡尔塔棋的算法研究与改进[J].中文科技期刊数据库(全文版)自然科学,2018,[计算机博弈苏拉卡尔塔棋的算法研究与改进 - 道客巴巴 (doc88.com)](https://www.doc88.com/p-3009165882898.html)



